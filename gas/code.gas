const props = PropertiesService.getScriptProperties();

// --- ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆè¨­å®š ---
const SS_URL = props.getProperty("SS_URL");     // ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®URL

function doGet() {

  const template = HtmlService.createTemplateFromFile('index');

  return template.evaluate()
    .setTitle('é§è»Šå ´ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

// --- å…±é€š: ã‚·ãƒ¼ãƒˆå–å¾—ãƒ˜ãƒ«ãƒ‘ãƒ¼ ---
function getSheet() {
  // --- è¨­å®šèª­ã¿è¾¼ã¿ ---

const SHEET_NAME = 'ã‚·ãƒ¼ãƒˆ1';
  if (!SS_URL) {
    throw new Error("ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ 'SS_URL' ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
  }
  const ss = SpreadsheetApp.openByUrl(SS_URL);
  const sheet = ss.getSheetByName(SHEET_NAME);
  if (!sheet) {
     throw new Error(`ã‚·ãƒ¼ãƒˆ '${SHEET_NAME}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚·ãƒ¼ãƒˆåã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
  }
  return sheet;
}

function getParkingData() {
  const ss = SpreadsheetApp.openByUrl(SS_URL);
  const sheet = ss.getSheetByName("ã‚·ãƒ¼ãƒˆ1");
  const data = sheet.getDataRange().getValues();
  const headers = data.shift();

  const result = data.map((row, index) => ({
    rowNum: index + 2,
    id: row[0],
    name: row[1],
    lat: row[2],
    lng: row[3],
    status: row[4]
  }));
  Logger.log(result)
  return result;
}

// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®æ›´æ–°
function updateStatus(rowNum, newStatus) {
  const ss = SpreadsheetApp.openByUrl(SS_URL);
  const sheet = ss.getSheetByName("ã‚·ãƒ¼ãƒˆ1");
  
  sheet.getRange(rowNum, 5).setValue(newStatus); // Eåˆ—: status
  return "æ›´æ–°å®Œäº†";
}

function deployToGithub() {
  //const props = PropertiesService.getScriptProperties();

  // --- GIthubè¨­å®š ---
  const CONFIG = {
    TOKEN: props.getProperty('GITHUB_API_TOKEN'), // GitHub Personal Access Token
    USER: props.getProperty('GITHUB_USER'),       // GitHubã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å
    REPO: props.getProperty('GITHUB_REPO'),       // ãƒªãƒã‚¸ãƒˆãƒªå
    FILE_PATH: 'index.html',                       // ä¿å­˜ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«å
    BRANCH: 'main'                                // ãƒ–ãƒ©ãƒ³ãƒå
  };

  // 1. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const parkingData = getParkingData(); 

  Logger.log(props.getProperty("TITLE"))

  // 2. HTMLã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆï¼ˆã“ã“ã§ãƒ‡ãƒ¼ã‚¿ã‚’JSå¤‰æ•°ã¨ã—ã¦åŸ‹ã‚è¾¼ã‚€ï¼‰
  const htmlContent = generateHtml(props.getProperty("TITLE"),parkingData);

  // 3. GitHub APIã§ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®SHAï¼ˆæŒ‡ç´‹ï¼‰ã‚’å–å¾—ï¼ˆæ›´æ–°ã«å¿…è¦ï¼‰
  const url = `https://api.github.com/repos/${CONFIG.USER}/${CONFIG.REPO}/contents/${CONFIG.FILE_PATH}`;
  const getRes = UrlFetchApp.fetch(url, {
    method: "get",
    headers: { "Authorization": "token " + CONFIG.TOKEN },
    muteHttpExceptions: true
  });

  let sha = "";
  if (getRes.getResponseCode() === 200) {
    sha = JSON.parse(getRes.getContentText()).sha;
  }

  // 4. GitHubã¸ãƒ—ãƒƒã‚·ãƒ¥ï¼ˆPUTï¼‰
  const payload = {
    message: "Update parking data via GAS",
    content: Utilities.base64Encode(htmlContent, Utilities.Charset.UTF_8),
    sha: sha // æ–°è¦ä½œæˆãªã‚‰ä¸è¦ã ãŒã€æ›´æ–°ãªã‚‰å¿…é ˆ
  };

  const options = {
    method: "put",
    headers: { "Authorization": "token " + CONFIG.TOKEN },
    contentType: "application/json",
    payload: JSON.stringify(payload)
  };

  const res = UrlFetchApp.fetch(url, options);
  Logger.log("Deploy Result: " + res.getResponseCode());
}

function generateHtml(title, data) {
  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’JSONæ–‡å­—åˆ—ã«å¤‰æ›
  const jsonData = JSON.stringify(data);

  const template = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        #map {
            height: calc(100vh - 80px);
            width: 100%;
            z-index: 1;
        }
        .status-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-weight: bold;
            color: white;
            font-size: 14px;
        }
        .status-empty { background-color: #10b981; }
        .status-crowded { background-color: #f59e0b; }
        .status-full { background-color: #ef4444; }
    </style>
</head>
<body class="bg-gray-50 flex flex-col h-screen overflow-hidden">

    <header class="bg-white shadow-sm p-4 flex justify-between items-center z-10">
        <h1 class="text-lg font-bold text-gray-800">${title}</h1>
        <div class="flex gap-2 text-xs font-medium">
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-emerald-500"></span>ç©ºã</span>
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-amber-500"></span>æ··é›‘</span>
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-red-500"></span>æº€è»Š</span>
        </div>
    </header>

    <main class="flex-grow relative">
        <div id="map"></div>
    </main>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        let map;
        // ãƒ‡ãƒ¼ã‚¿ã®æµã—è¾¼ã¿
        const locations = ${jsonData};
        let points = [];

        window.onload = function() {
            initMap();
        };

        function initMap() {
            map = L.map('map', { zoomControl: false });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            L.control.zoom({ position: 'bottomright' }).addTo(map);

            locations.forEach(loc => {
                addStatusMarker(loc);
                points.push([loc.lat, loc.lng]);
            });

            if (points.length > 0) {
                const bounds = L.latLngBounds(points);
                map.fitBounds(bounds);
            }
        }

        function addStatusMarker(loc) {
            let statusClass = 'status-empty';
            let statusLabel = loc.status;
            
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¤å®šï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®å€¤ã«åˆã‚ã›ã‚‹ï¼‰
            if (loc.status === 'ç©ºã' || loc.status === 'ç©º') statusClass = 'status-empty';
            else if (loc.status === 'æ··é›‘' || loc.status === 'æ··') statusClass = 'status-crowded';
            else if (loc.status === 'æº€è»Š' || loc.status === 'æº€') statusClass = 'status-full';

            const customIcon = L.divIcon({
                className: 'status-marker ' + statusClass,
                html: '<span>' + statusLabel.substring(0,1) + '</span>',
                iconSize: [36, 36],
                iconAnchor: [18, 18]
            });

            const marker = L.marker([loc.lat, loc.lng], { icon: customIcon }).addTo(map);

            const popupContent = \`
                <div class="p-1">
                    <h3 class="font-bold text-gray-800">\${loc.name}</h3>
                    <p class="text-sm">çŠ¶æ³: \${loc.status}</p>
                    <a href="https://www.google.com/maps/dir/?api=1&destination=\${loc.lat},\${loc.lng}" 
                       target="_blank" class="text-blue-500 text-xs mt-2 block">ğŸš— ãƒ«ãƒ¼ãƒˆæ¡ˆå†…</a>
                </div>
            \`;
            marker.bindPopup(popupContent);
        }
    </script>
</body>
</html>`;
  return template;
}